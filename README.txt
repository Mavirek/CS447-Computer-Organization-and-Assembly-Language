CS 447
Project 1
Allen Poon
Tues-Thurs: 9:30 - 10:45

Gameboard:
I created the gameboard by making a 'board' variable in ascii with '#' as walls, ' ' as empty space, 'P' for the starting player location, 'T' for the treasure location, 'R' for the red key location, 'G' for the green key location, and 'B' for the blue key location. All except the treasure object were initialized with the gameboard during string parsing. The dragon, treasure, and door objects were later put in after the board was initialized due to the way the gameboard was parsed. 'board' was read in one character at a time horizontally via a X&Y nested for-loop and the corresponding LED was lit on the simulator while also marking the proper numeric symbol on the 4 kb collision memory map ('map' variable) representation of the gameboard. Because of the horizontal parsing of the gameboard, it would be overly complicated to try to set up an object with multiple LEDs such as a dragon or a vertical door while also conpensating for the X and Y counters in the nested for-loop to prevent creating more than one of that object while marking the object's collision map correctly. I solved that issue by simply initializing the dragon, treasure, and door objects after the gameboard was initialized - that way I could manually mark the collision memory map positions and replace the walls (1's) or empty space (0's) initially marked by the gameboard.

See README_MAP.txt for a more detailed visual of the gameboard

Collisions:
With the creation of the collision map upon game initialization, most of the work for collision testing mainly involves using the map_get_wall function, which takes the X-argument in a0 and Y-argument in a1 and returns the location on the memory map in v0. For each collision with the wall, dragon, treasure, key, and door objects, I simply compare v0 with the corresponding memory map numeric symbol. For example, when doing collision testing for a treasure object, it would check if the next move would run into a location that contained an '8' on the memory map. For objects that can disappear upon collision, collision testing for this is done by checking a certain attribute in that object such as doorRLocked or keyRCollected. Depending on the status of those attributes, the game would continue onto or skip the display code of that object. For example, if the player would run into a red door while doorRLocked is 0 and keyRCollected is 0, then the collision would be treated as a wall and stop the player movement.

Player:
During each gametick, gameLoop would check for WASD & B input. checkMove would check for the previous direction used in t5 and continue in that direction if no key was pressed and no collision has occurred. In each movement direction before making the actual move, the game would do collision testing by using the X and Y arguments for the upcoming move and test if it would collide with a wall, door, key, treasure, or dragon. If no collisions are present, then make the move and check the tick time. If there are collisions with the wall or a locked door, then the movement direction in t5 would be reset to 0 and the last key pressed in t4 would be set to as if no key was pressed.

Dragon:
The dragon object code structure is similar to the player object's. At the beginning of each game tick, calculations would be made to compare the player's X coordinate with the dragon's X coordinate and the player's Y coordinate with the dragon's Y coordinate in relation to the distance formula. If the distance falls within 64 or less, then the dragon begins chasing the player. Else if it's greater than 64, then the dragon goes back to roaming. When chasing, the player's current position is calculated and stored in t8 and the dragon's current position is calculated and stored in t9. Similar calculations with playerX-dragonX and playerY-dragonY are then performed. The result of playerX-dragonX is added onto the dragon's current position and is stored in t7; the same is done with playerY-dragonY and added and stored in t9. t7 is then subtracted from the player position (t8). If the result is 0, then the dragon knows to chase on the X-axis. Otherwise, chase on the Y-axis. The roaming state is done via a random number generator from 0-4. Both roam and chase follow the same movement structure, which is similar to the player's in terms of collision with the exception for keys.